  MODULE FADDEYEVA_V3_MOD_RK
    USE SET_RK
    IMPLICIT NONE

    INCLUDE 'FADDEYEVA_V3_PARAMETERS.F90'
    PRIVATE
    PUBLIC :: FADDEYEVA_V3_RK


  CONTAINS



    ! !::************************************************************************************
    ! !::************************************************************************************
    ! ..
    ELEMENTAL SUBROUTINE FADDEYEVA_V3_RK(Z, W, SDGTS, STAT)

      ! ----------
      ! FADDEYEVA_V3_RK IS AN ELEMENTAL FORTRAN SUBROUTINE THAT RECEIVES, AS INPUT,
      ! A SCALAR OR AN ARRAY Z OF COMPLEX NUMBERS AND RETURNS AS OUTPUT A SCALER OR
      ! AN ARRAY OF THE CORRESPONDING FADDEYEVA FUNCTION,W, DEFINED AS
      ! W(Z)=EXP(-Z^2)*ERFC(-I*Z) WHERE ERFC(Z) IS THE COMPLEX COMPLEMENTARY
      ! ERROR FUNCTION. AN OPTIONAL INTEGER INPUT (SDGTS), MAY BE USED REPRESENTING
      ! THE DESIRED NUMBER OF SIGNIFICANT DIGITS IN THE CALCULATED FADDEYEVA FUNCTION.
      ! ------------
      ! ------------
      ! THE ROUTINE CAN BE RUN IN DEFAULT REAL (SINGLE PRECISION), IN DOUBLE
      ! PRECISION OR IN QUADRUPLE PRECISION DEPENDING ON THE CHOICE OF THE INTEGER
      ! PARAMETER "RK" IN THE SUBSIDIARY MODULE "SET_RK"
      ! -------------
      ! THE SUBROUTINE IS SET TO REPRODUCE THE HIGHEST POSSIBLE ACCURACY OBTAINABLE
      ! FROM ALGORITHM 916 [ZAGHLOUL AND ALI,TOMS, VOL. 38, NO. 2, ARTICLE 15:1-22
      ! (2011) & ZAGHLOUL M. ,ACM TOMS, VOL. 42, NO. 3, ARTICLE 26:1-9 (2016) ]
      ! THROUGH REQUESTING A NUMBER OF SIGNIFICANT DIGITS (SDGTS) EQUAL
      ! TO 14 WHEN RUN IN DOUBLE PRECISION. HOWEVER, THIS VERSION (WHEN RUN USING
      ! DOUBLE PRECISION ARITHMETIC EMBODIES SIGNIFICANT EFFICIENCY IMPROVEMENTS
      ! COMPARED TO THE PREVIOUS FORTRAN VERSION "FADDEYEVA_V2.F90" [ZAGHLOUL (2016)]

      ! THE DESIRED NUMBER OF SIGNIFICANT DIGITS CAN BE REDUCED FOR MARGINAL
      ! IMPROVEMENTS OF THE EFFICIENCY AT THE EXPENSE OF ACCURACY.
      ! THE RECOMMENDED RANGE FOR "SDGTS" IS BETWEEN 4 AND 6 FOR SINGLE PRECISION,
      ! 4 AND 14 FOR DOUBLE PRECISION AND BETWEEN 4 AND 31 FOR QUAD PRECISION.
      ! A NUMBER OF SIGNIFICANT DIGITS SMALLER THAN 4 IS NOT RECOMMENDED FOR ACCURACY
      ! CONCERNS, PARTICULARLY REGARDING THE COMPUTATIONS OF THE DERIVATIVES (IF NEEDED),
      ! ANT IT WILL BE AUTOMATICALLY CHANGED TO 4.

      ! VALUES OF SDGTS >14 FOR DOUBLE PRECISION ARE NOT RECOMMENDED FOR PERFORMANCE
      ! CONCERNS AND WILL BE AUTOMATICALLY CHANGED TO 14.
      ! SIMILARLY, VALUES OF SDGTS > 6 FOR SINGLE PRECISION ARE NOT RECOMMENDED
      ! FOR PERFORMANCE CONCERNS AND WILL BE AUTOMATICALLY CHANGED TO 6.
      ! FOR TARGETED ACCURACY BETWEEN 15 AND 31 SIGNFICANT DIGITS, ONE HAS TO
      ! USE QUAD PRECISIN THRROUGH SETTING RK=QP IN THE AUXILARY MODULE "SET_RK"

      ! ALSO WHEN USING QUAD PRECISION VALUES OF SDGTS > 31 ARE CHANGED AUTOMATICALLY
      ! TO 31

      ! AN OPTIONAL "STAT" ARGUMENT IS USED BECAUSE "WRITE" STATEMENTS ARE NOT PERMITTED
      ! IN ELEMENTAL SUBROUTINES. THE "STAT" RETURNS INTEGER VALUES 0,1,2 AND -1
      ! CORRESPONDING TO NORMAL, TOO FEW SIGNIFICANT FIGURES <4, TOO MANY SIGNIFICANT
      ! FIGURES (>31 FOR QUAD PRECISION, >14 FOR DOUBLE PRECISION AND >6 FOR DEFAULT REAL
      ! OR SINGLE PRECISION) AND OVERFLOW, RESPECTIVELY.
      ! ----------
      ! THE ACCOMPANYING DRIVER CODE “FADDEYEVA_V3_DRIVER_RK.F90” CAN BE RUN FOR
      ! COMPUTATION OF THE FADDEYEVA FUNCTION W(Z)=V+IL, ON A SCALAR OR AN ARRAY
      ! OF THE COMPLEX VARIABLE Z.
      ! ----------
      ! -----------
      ! -----------
      ! COPYRIGHT (C) [2023]
      ! AUTHOR: MOFREH R. ZAGHLOUL
      ! UNITED ARAB EMIRATES UNIVERSITY, DECEMBER 3, 2023
      ! ALL RIGHTS RESERVED.
      ! SOFTWARE NAME: FADDEYEVA
      ! VERSION: 3
      ! THIS SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
      ! INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
      ! PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHOR OR COPYRIGHT HOLDER BE LIABLE
      ! FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      ! OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
      ! OTHER DEALINGS IN THE SOFTWARE.

      ! REDISTRIBUTION AND USE IN SOURCE AND BINARY FORMS, WITH OR WITHOUT MODIFICATION, ARE
      ! PERMITTED PROVIDED THAT THE FOLLOWING CONDITIONS ARE MET:
      ! 1. REDISTRIBUTIONS OF SOURCE CODE MUST RETAIN THE ABOVE COPYRIGHT NOTICE, THIS LIST OF
      ! CONDITIONS AND THE FOLLOWING DISCLAIMER.
      ! 2. REDISTRIBUTIONS IN BINARY FORM MUST REPRODUCE THE ABOVE COPYRIGHT NOTICE, THIS LIST OF
      ! CONDITIONS AND THE FOLLOWING DISCLAIMER IN THE DOCUMENTATION AND/OR OTHER MATERIALS
      ! PROVIDED WITH THE DISTRIBUTION.
      ! 3. THIS SOFTWARE CANNOT BE USED FOR COMMERCIAL PURPOSES WITHOUT SPECIFIC PRIOR WRITTEN
      ! PERMISSION.
      ! 4. PROPER CITATION TO THE ORIGINAL PAPER MUST BE MADE IN ANY PUBLICATIONS OR PRODUCTS USING
      ! THIS SOFTWARE: ZAGHLOUL, M. R., “EFFICIENT NUMERICAL ALGORITHMS FOR MULTI-PRECISION
      ! CALCULATION OF THE ERROR FUNCTIONS AND DAWSON INTEGRAL OF COMPLEX ARGUMENTS,”
      ! NUMERICAL ALGORITHMS (2024)  HTTPS://DOI.ORG/10.1007/S11075-023-01727-2.
      ! ----------


      COMPLEX (RK), INTENT (IN) :: Z
      INTEGER, INTENT (IN), OPTIONAL :: SDGTS
      COMPLEX (RK), INTENT (OUT) :: W
      INTEGER, INTENT (OUT), OPTIONAL :: STAT

      REAL (RK) :: XSQR_PLUS_YSQR, YSQR_MINUS_XSQR, X_SQR, Y_SQR, XX, YY, X_ABS, Y_ABS
      
      INTEGER :: NDGTS

      IF (.NOT. PRESENT(SDGTS)) NDGTS = 4
      IF (PRESENT(SDGTS)) NDGTS = SDGTS
      IF (PRESENT(STAT)) STAT = 0
      IF (NDGTS<4) THEN
        IF (PRESENT(STAT)) STAT = 1
        NDGTS = 4
      ELSE IF (NDGTS>NDGTS_MAX) THEN
        IF (PRESENT(STAT)) STAT = 2
        NDGTS = NDGTS_MAX
      END IF

      XX = REAL(Z, KIND=RK)
      YY = AIMAG(Z)

      X_ABS = ABS(XX)
      Y_ABS = ABS(YY)
      IF (X_ABS>=SQRT_RMIN) THEN
        X_SQR = XX*XX
      ELSE
        X_SQR = ZERO
      END IF
      IF (Y_ABS>=SQRT_RMIN) THEN
        Y_SQR = YY*YY
      ELSE
        Y_SQR = ZERO
      END IF

      YSQR_MINUS_XSQR = Y_SQR - X_SQR
      XSQR_PLUS_YSQR = X_SQR + Y_SQR


      ! IF (YY<ZERO .AND. (YSQR_MINUS_XSQR)>=ABS_LOG_RMIN) THEN
      ! IF (PRESENT(STAT)) STAT = -1
      ! RETURN
      IF (Y_ABS<RMIN .AND. X_ABS<SQRT_ABS_LOG_RMIN) THEN
        W = EXP(-X_SQR) + J1*TWO_SQRT_PI*DAWSON_RK(XX)
      ELSE IF (Y_ABS<RMIN .AND. X_ABS>SQRT_ABS_LOG_RMIN) THEN
        W = ZERO + J1*TWO_SQRT_PI*DAWSON_RK(XX)
        RETURN
      ELSE IF (X_ABS<RMIN) THEN
        W = ERFCX_RK(YY)
        RETURN
      END IF


      IF (NDGTS>4) THEN


        ! --------OUTER REGION ----> ASYMPTOTIC SERIES EXPANSION FOR LARGE |Z|
        IF (XSQR_PLUS_YSQR>=127.0E0_RK-40.0E0_RK*(SP/RK)) THEN

          W = USE_BIGZ_SERIES(Z, TOLERANCE(SDGTS))

          ! --------INNER REGION ----> TAYLOR SERIES FOR SMALL |Z|
        ELSE IF (XSQR_PLUS_YSQR<=2.24E0_RK) THEN
          W = USE_SMALLZ_SERIES(Z, TOLERANCE(SDGTS))
          RETURN

          ! ------VERY SMALL Y REGION ----> TAYLOR SERIES OF DAWSON'S INTEGRAL
        ELSE IF (Y_SQR<=1.0E-15_RK) THEN
          W = USE_TAYLOR_DAW(XX, Y_ABS, 1)

        ELSE IF (Y_SQR<=1.0E-6_RK) THEN
          W = USE_TAYLOR_DAW(XX, Y_ABS, NTAYLOR2_QP(NDGTS-3))

        ELSE IF (Y_SQR<=1.0E-3_RK) THEN
          W = USE_TAYLOR_DAW(XX, Y_ABS, NTAYLOR3_QP(NDGTS-3))

          ! ------ REMAINING REGION ----> LOOP FOR|X|<SQRT(-LOG(R_MIN)) SIMILAR TO
          ! ALGORITHM 916-V2 WITH PRECISION DEPENDENT VALUE OF THE PARAMETER A
        ELSE
          W = USE_CYCLES_1(XX, YY, NCYCLES_QP(NDGTS-3))
        END IF

      ELSE
        ! HIGHLY EFFICIENT VERSION FOR 4 SD ACCURACY BASED ON ALGORITHM 985
        ! AND CORRECTED HUMLICEK W4 ALGORITHM

        IF (XSQR_PLUS_YSQR>=16.0E3_RK) THEN
          ! :-  W=((J1* ONE_SQRT_PI)/Z)
          W = (YY+J1*XX)*(ONE_SQRT_PI/XSQR_PLUS_YSQR)

        ELSE IF (XSQR_PLUS_YSQR>=16.0E1_RK) THEN
          W = ((Y_ABS*(HALF+XSQR_PLUS_YSQR))+J1*(XX*(XSQR_PLUS_YSQR-HALF)))*(ONE_SQRT_PI/(( &
            XSQR_PLUS_YSQR*XSQR_PLUS_YSQR+YSQR_MINUS_XSQR)+QUARTER))

        ELSE IF (XSQR_PLUS_YSQR>=25.0E0_RK .AND. Y_SQR>1.0E-13_RK) THEN
          W = -YSQR_MINUS_XSQR + J1*TWO*XX*Y_ABS
          W = (ONE_SQRT_PI*(-Y_ABS+J1*XX))*(W-2.5_RK)/(W*(W-3.0E0_RK)+0.75E0_RK)

        ELSE IF (YY>=0.195E0_RK*ABS(XX)-0.176E0_RK) THEN
          W = Y_ABS - J1*XX
          W = (16.4955_RK+W*(20.20933_RK+W*(11.96482_RK+W*(3.778987_RK+0.5642236_RK*W))))/( &
            16.4955_RK+W*(38.82363_RK+W*(39.27121_RK+W*(21.69274_RK+W*(6.699398_RK+W)))))

        ELSE IF (YY*XX<1.0E-5_RK .AND. YSQR_MINUS_XSQR>=-SQRT_ABS_LOG_RMIN) THEN
          W = YSQR_MINUS_XSQR - J1*TWO*XX*Y_ABS
          W = EXP(YSQR_MINUS_XSQR) - (-J1*(XX+J1*Y_ABS)*(36183.31_RK-W*(3321.99_RK-W*(1540.787_RK-W* &
            (219.031_RK-W*(35.7668_RK-W*(1.320522_RK-W*0.56419_RK))))))/(32066.6_RK-W*(24322.84_RK- &
            W*(9022.228_RK-W*(2186.181_RK-W*(364.2191_RK-W*(61.57037_RK-W*(1.841439_RK-W))))))))

        ELSE
          W = YSQR_MINUS_XSQR - J1*TWO*XX*Y_ABS
          W = EXP(W) - (-J1*(XX+J1*Y_ABS)*(36183.31_RK-W*(3321.99_RK-W*(1540.787_RK-W*(219.031_RK-W* &
            (35.7668_RK-W*(1.320522_RK-W*0.56419_RK))))))/(32066.6_RK-W*(24322.84_RK- &
            W*(9022.228_RK-W*(2186.181_RK-W*(364.2191_RK-W*(61.57037_RK-W*(1.841439_RK-W))))))))

        END IF
      END IF

      ! IF (YY<ZERO) THEN
      ! W = TWO*EXP(YSQR_MINUS_XSQR+J1*TWO*Y_ABS*XX) - (REAL(W)-J1*AIMAG(W))
      ! END IF

    END SUBROUTINE
    ! !*************************************


    ! :- EVALUATION OF THE ASYMPTOTIC SERIES |Z|^2>127 USING
    ! DYNAMIC CHOICE OF THE NUMBER OF TERMS NEEDED.

    ELEMENTAL FUNCTION USE_BIGZ_SERIES(Z, EPS_TRC) RESULT (W)
      COMPLEX (RK), INTENT (IN) :: Z
      REAL (RK), INTENT (IN) :: EPS_TRC
      COMPLEX (RK) :: ALPHA, W, F_N
      INTEGER :: N

      ALPHA = HALF/(Z*Z)
      F_N = (ONE, ZERO)
      W = F_N
      DO N = 1, 74, 2
        F_N = F_N*N*ALPHA
        W = W + F_N
        IF (ABS(REAL(F_N,KIND=RK))<ABS(REAL(W,KIND=RK))*EPS_TRC .AND. ABS(AIMAG(F_N))<ABS(AIMAG(W))* &
          EPS_TRC) EXIT
      END DO
      W = (J1*ONE_SQRT_PI/Z)*W
    END FUNCTION
    ! :--

    ! :- EVALUATION OF THE TAYLOR SERIES FOR SMALL |Z|
    ! (ABRAMOWITZ & STEGUN 7.1.8)USING
    ! DYNAMIC CHOICE OF THE NUMBER OF TERMS NEEDED.

    ELEMENTAL FUNCTION USE_SMALLZ_SERIES(Z, EPS_TRC) RESULT (W)
      COMPLEX (RK), INTENT (IN) :: Z
      REAL (RK), INTENT (IN) :: EPS_TRC
      COMPLEX (RK) :: ALPHA, W, F_N
      INTEGER :: N

      ALPHA = J1*Z
      F_N = (ONE, ZERO)
      W = F_N
      DO N = 1, 70
        F_N = F_N*GAMMA_RATIO(N)*ALPHA
        W = W + F_N
        IF (ABS(REAL(F_N,KIND=RK))<ABS(REAL(W,KIND=RK))*EPS_TRC .AND. ABS(AIMAG(F_N))<ABS(AIMAG(W))* &
          EPS_TRC) EXIT
      END DO

    END FUNCTION


    ! :--
    ! :*************************

    ! :--
    ! USE  OF A FEW TERMS OF TAYLOR SERIES OF DAWSON'S FUNCTION NEAR
    ! THE REAL AXIS
    ELEMENTAL FUNCTION USE_TAYLOR_DAW(XX, YY, NTERMS) RESULT (W)
      REAL (RK), INTENT (IN) :: XX, YY
      INTEGER, INTENT (IN) :: NTERMS
      INTEGER :: N
      COMPLEX (RK) :: W, DEL_W
      REAL (RK) :: X_SQR, Y_SQR, YSQR_MINUS_XSQR, TWO_XY, DW
      REAL (RK), DIMENSION (20) :: D

      X_SQR = XX*XX
      Y_SQR = YY*YY

      YSQR_MINUS_XSQR = Y_SQR - X_SQR
      TWO_XY = TWO*XX*YY
      DW = DAWSON_RK(XX)
      D(1) = (ONE-TWO*XX*DW)
      W = EXP(YSQR_MINUS_XSQR)*(COS(TWO_XY)-J1*SIN(TWO_XY)) + (TWO_SQRT_PI*J1)*(DW+D(1)*J1*YY)

      IF (NTERMS>1) THEN
        D(2) = -(XX*D(1)+DW)
        DEL_W = (TWO_SQRT_PI*J1)*(-Y_SQR)
        W = W + DEL_W*D(2)
        DO N = 3, NTERMS + 1
          D(N) = -(2.0E0_RK/N)*(XX*D(N-1)+D(N-2))
          DEL_W = DEL_W*J1*YY
          W = W + DEL_W*D(N)
        END DO
      END IF

    END FUNCTION


    ! !:- REWORKED ALGORITHM 916 TO INCREASE ACCURACY TO 31 SD
    ! WHEN USING QUADRUPLE PRECISION AIRTHMETIC

    ELEMENTAL FUNCTION USE_CYCLES_1(XX, YY, NCYCLES) RESULT (W)
      REAL (RK), INTENT (IN) :: XX, YY
      INTEGER, INTENT (IN) :: NCYCLES
      COMPLEX (RK) :: W
      REAL (RK) :: COS_2YX, DEL2_TMP, DEL3_TMP, DEL3_3_TMP, DEN1, ERFCX_Y, EXP_X_SQR, EXP1, EXP2, &
        EXP3, EXP3_DEN, EXP3_3_DEN, N3, N3_3, SIGMA1, SIGMA2_3, SIGMA4_5, TWO_X, TWO_YX, TWO_A_X, X, &
        Y, YSQR, Y_SQR_A_SQR, TWO_NN_AX
      INTEGER :: N

      Y = ABS(YY)
      X = ABS(XX)

      YSQR = Y*Y
      EXP_X_SQR = EXP(-X*X)
      ERFCX_Y = ERFCX_RK(Y)
      TWO_X = TWO*X
      TWO_A_X = A*TWO_X
      TWO_YX = Y*TWO_X
      COS_2YX = COS(TWO_YX)
      N3 = REAL(CEILING(X/A), KIND=RK)
      N3_3 = N3 - ONE
      Y_SQR_A_SQR = INV_A_SQR*YSQR

      SIGMA1 = ZERO
      SIGMA2_3 = ZERO
      SIGMA4_5 = ZERO

      EXP1 = EXP(-TWO_A_X)
      EXP3 = EXP(-TWO_A_SQR*N3_3+TWO_A_X)
      EXP2 = EXP_2A_SQR/(EXP3*EXP3)

      DEL2_TMP = ONE
      DEL3_TMP = EXP(-((A_SQR*N3*N3-TWO_A_X*N3-TWO_A_SQR*N3)+X*X+TWO_A_X+A_SQR))
      DEL3_3_TMP = EXP_A_SQR*EXP3

      DO N = 1, NCYCLES
        DEN1 = INV_ASQR_EXP_ASQR_NSQR(N)*EXP_X_SQR/(N*N+Y_SQR_A_SQR)
        DEL2_TMP = DEL2_TMP*EXP1
        DEL3_TMP = DEL3_TMP*EXP3
        EXP3_DEN = DEL3_TMP*INV_ASQR_EXP_ASQR_NSQR(N)/((N3_3+N)**2+Y_SQR_A_SQR)
        SIGMA1 = SIGMA1 + DEN1
        IF (N3_3>=N) THEN
          DEL3_3_TMP = DEL3_3_TMP*EXP2
          EXP3_3_DEN = DEL3_3_TMP*DEL3_TMP*INV_ASQR_EXP_ASQR_NSQR(N)/((N3-N)**2+Y_SQR_A_SQR)
          SIGMA2_3 = SIGMA2_3 + DEL2_TMP*DEN1 + EXP3_3_DEN + EXP3_DEN
          SIGMA4_5 = SIGMA4_5 + (N3-N)*EXP3_3_DEN + (N3_3+N)*EXP3_DEN - N*DEL2_TMP*DEN1
        ELSE
          SIGMA2_3 = SIGMA2_3 + DEL2_TMP*DEN1 + EXP3_DEN
          IF (X>=1.00E-3_RK*CNST1) THEN
            SIGMA4_5 = SIGMA4_5 + (N3_3+N)*EXP3_DEN - N*DEL2_TMP*DEN1
          ELSE
            TWO_NN_AX = N*N*TWO_A_X
            SIGMA4_5 = SIGMA4_5 + TWO*TWO_NN_AX*DEN1*(ONE+SIXTH*TWO_NN_AX*TWO_A_X+HUNTW*(TWO_NN_AX* &
              TWO_A_X)**2+(1.984126984126984126984126984126984126984E-4_RK)*(TWO_NN_AX*TWO_A_X)**3+ &
              (2.755731922398589065255731922398589065256E-6_RK)*(TWO_NN_AX*TWO_A_X)**4)
            ! +&
            ! (HUNTW/42.0E0_RK/72.0E0_RK/111.0E0_RK)*(N*N*TWO_A_X*TWO_A_X)**5)
          END IF
        END IF
      END DO

      IF (Y<CNST2 .AND. TWO_YX>RMIN) THEN
        W = (EXP_X_SQR*(ERFCX_Y*COS_2YX+(TWO_A_PI/Y)*SIN(TWO_YX*HALF)**2)+Y*TWO_A_PI*(-COS_2YX* &
          SIGMA1+HALF*SIGMA2_3)+J1*SIGN(ONE,XX)*(SIN(TWO_YX)*(EXP_X_SQR*(-ERFCX_Y+HALF*TWO_A_PI/Y)+ &
          TWO_A_PI*Y*SIGMA1)+TWO_A_PI_HALF_A*SIGMA4_5))

      ELSE IF ((Y<CNST2) .AND. TWO_YX<=RMIN) THEN
        W = (EXP_X_SQR*(ERFCX_Y*COS_2YX+(TWO_A_PI/Y)*SIN(TWO_YX*HALF)**2)+Y*TWO_A_PI*(-COS_2YX* &
          SIGMA1+HALF*SIGMA2_3)+J1*SIGN(ONE,XX)*(Y*(TWO_X*EXP_X_SQR*(-ERFCX_Y+HALF*TWO_A_PI/Y)+ &
          TWO_X*TWO_A_PI*Y*SIGMA1)+TWO_A_PI_HALF_A*SIGMA4_5))
      ELSE
        W = (EXP_X_SQR*(ERFCX_Y*COS_2YX+(TWO_A_PI/Y)*SIN(TWO_YX*HALF)**2)+Y*TWO_A_PI*(-COS_2YX* &
          SIGMA1+HALF*SIGMA2_3)+J1*SIGN(ONE,XX)*TWO_A_PI_HALF_A*SIGMA4_5)
      END IF

    END FUNCTION

    ! ==============


    ELEMENTAL FUNCTION DAWSON_RK(X)
      ! DAWSON_RK EVALUATES THE DAWSON INTEGRAL OF A REAL ARGUMENT,X;
      ! DAWSON(X)=EXP(-X^2)*INT(0 <= T <= X) EXP(T^2 ) DT

      ! THE CALLING SEQUENCE FOR THIS FUNCTION IS
      ! Y=DAWSON_RK(X)
      ! THE FUNCTION CAN BE EVALUATED USING SINGLE, DOUBLE AND QUADRUPLE
      ! PRECISION DEPENDING ON THE CHOICE OF THE INTEGER "RK" IN THE
      ! ASSOCIATED MODULE "SET_RK"
      ! !---------------

      IMPLICIT NONE
      REAL (RK), INTENT (IN) :: X
      REAL (RK) :: AX, DAWSON_RK
      REAL (RK) :: Y100, T
      INTEGER :: J, YCASE, JMIN
      INCLUDE 'CHEB_T100_DAW_PARAMETERS_SDQ.F90'

      AX = ABS(X)
      IF (BIG_BORDER_12<AX) THEN
        DAWSON_RK = HALF/X
      ELSE IF (AX<=XSMALL) THEN
        DAWSON_RK = X
      ELSE IF (AX<=SMALL_BORDER_1) THEN
        DAWSON_RK = PRIV_NCONT_FRAC0(1, X)
      ELSE IF (AX<=SMALL_BORDER_2) THEN
        DAWSON_RK = PRIV_NCONT_FRAC0(2, X)
      ELSE IF (AX<=SMALL_BORDER_3) THEN
        DAWSON_RK = PRIV_NCONT_FRAC0(3, X)
      ELSE IF (AX<=SMALL_BORDER_4) THEN
        DAWSON_RK = PRIV_NCONT_FRAC0(4, X)
      ELSE IF (AX<=SMALL_BORDER_5) THEN
        DAWSON_RK = PRIV_NCONT_FRAC0(5, X)
      ELSE IF (AX<=SMALL_BORDER_6) THEN
        DAWSON_RK = PRIV_NCONT_FRAC0(6, X)
      ELSE IF (AX<=SMALL_BORDER_7) THEN
        DAWSON_RK = PRIV_NCONT_FRAC0(7, X)
      ELSE IF (AX<=CHEB_AX) THEN
        Y100 = ONE80/(AX+ONE_PT_8)
        YCASE = (Y100)
        T = TWO*Y100 - (TWO*YCASE+ONE)
        JMIN = YCASE*NP_PLS_1 + 1
        DAWSON_RK = T*CFFS(JMIN)
        DO J = JMIN + 1, JMIN + NP_MIN_1
          DAWSON_RK = T*(DAWSON_RK+(CFFS(J)))
        END DO
        DAWSON_RK = (DAWSON_RK+CFFS(JMIN+NP))*((1-C_AX)*AX+C_AX) & ! C_AX=(RK/QP)+(SP/RK))
          *SIGN(ONE, X)

      ELSE IF (AX<=BIG_BORDER_1) THEN
        DAWSON_RK = PRIV_NCONT_FRAC(12, X)
      ELSE IF (AX<=BIG_BORDER_2) THEN
        DAWSON_RK = PRIV_NCONT_FRAC(11, X)
      ELSE IF (AX<=BIG_BORDER_3) THEN
        DAWSON_RK = PRIV_NCONT_FRAC(10, X)
      ELSE IF (AX<=BIG_BORDER_4) THEN
        DAWSON_RK = PRIV_NCONT_FRAC(9, X)
      ELSE IF (AX<=BIG_BORDER_5) THEN
        DAWSON_RK = PRIV_NCONT_FRAC(8, X)
      ELSE IF (AX<=BIG_BORDER_6) THEN
        DAWSON_RK = PRIV_NCONT_FRAC(7, X)
      ELSE IF (AX<=BIG_BORDER_7) THEN
        DAWSON_RK = PRIV_NCONT_FRAC(6, X)
      ELSE IF (AX<=BIG_BORDER_8) THEN
        DAWSON_RK = PRIV_NCONT_FRAC(5, X)
      ELSE IF (AX<=BIG_BORDER_9) THEN
        DAWSON_RK = PRIV_NCONT_FRAC(4, X)
      ELSE IF (AX<=BIG_BORDER_10) THEN
        DAWSON_RK = PRIV_NCONT_FRAC(3, X)
      ELSE IF (AX<=BIG_BORDER_11) THEN
        DAWSON_RK = PRIV_NCONT_FRAC(2, X)
      ELSE IF (AX<=BIG_BORDER_12) THEN
        DAWSON_RK = X/(TWO*X*X-ONE)
      END IF
      RETURN
    END FUNCTION

    ! :---------------------------------------------------
    ! LAPLACE CONTINUED FRACTION FOR LARGE VALUES OF X
    ! :---------------------------------------------------
    ELEMENTAL FUNCTION PRIV_NCONT_FRAC(M, X) RESULT (Y)
      IMPLICIT NONE
      REAL (RK), INTENT (IN) :: X
      INTEGER, INTENT (IN) :: M
      REAL (RK) :: Y
      INTEGER :: K

      Y = REAL(M, KIND=RK)/X
      DO K = M - 1, 1, -1
        Y = REAL(K, KIND=RK)/(X-HALF*Y)
      END DO
      Y = ONE/(TWO*X-Y)
      RETURN
    END FUNCTION

    ! ----------------------------------------------------------
    ! CONTINUED FRACTION EXPANSION FOR |X| NEAR THE ORIGIN
    ! ----------------------------------------------------------
    ELEMENTAL FUNCTION PRIV_NCONT_FRAC0(M, X) RESULT (Y)

      IMPLICIT NONE
      REAL (RK), PARAMETER :: LC_0_CFF(15) = (/ 0.66666666666666666666666666666666666666667_RK, &
        -0.26666666666666666666666666666666666666667_RK, &
        0.17142857142857142857142857142857142857142_RK, &
        -0.12698412698412698412698412698412698412698_RK, &
        0.10101010101010101010101010101010101010101_RK, &
        -0.08391608391608391608391608391608391608392_RK, &
        0.07179487179487179487179487179487179487179_RK, &
        -0.06274509803921568627450980392156862745098_RK, &
        0.05572755417956656346749226006191950464396_RK, &
        -0.05012531328320802005012531328320802005013_RK, &
        0.04554865424430641821946169772256728778468_RK, &
        -0.04173913043478260869565217391304347826087_RK, &
        0.03851851851851851851851851851851851851852_RK, &
        -0.03575989782886334610472541507024265644955_RK, &
        0.03337041156840934371523915461624026696329_RK /)

      REAL (RK), INTENT (IN) :: X
      INTEGER, INTENT (IN) :: M
      REAL (RK) :: Y
      REAL (RK) :: X_SQR
      INTEGER :: K

      X_SQR = X*X
      Y = LC_0_CFF(M)*X_SQR
      DO K = M - 1, 1, -1
        Y = LC_0_CFF(K)*X_SQR/(ONE+Y)
      END DO
      Y = X/(ONE+Y)
      RETURN
    END FUNCTION




    ! ===============================

    ELEMENTAL FUNCTION ERFCX_RK(X)

      ! ERFCX_RK IS AN ELEMENTAL FUNCTION THAT EVALUATES THE
      ! SCALED COMPLEMENTARY ERROR FUNCTION OF A REAL ARGUMENT X,
      ! I.E. "EXP(X*X) * ERFC(X)".

      ! THE FUNCTION ERFCX_RK(X) RECEIVES "X" AS AN INPUT AND RETURNS "ERFCX_RK'
      ! FOR THE SCALED COMPLEMENTARY ERROR FUNCTION USING THE PRECISION
      ! ARITHMETIC DETERMINED BY THE INTEGER "RK" SET IN THE SUBSIDIARY MODULE
      ! "SET_RK".
      ! AN OPTIONAL "STAT" ARGUMENT IS USED BECAUSE "WRITE" STATEMENTS ARE NOT PERMITTED
      ! IN ELEMENTAL SUBROUTINES. THE "STAT" RETURNS INTEGER VALUES 0,1,2 AND -1
      ! CORRESPONDING TO NORMAL, TOO FEW SIGNIFICANT FIGURES <4, TOO MANY SIGNIFICANT
      ! FIGURES (>13 FOR DOUBLE PRECISION AND >6 FOR DEFAULT REAL OR SINGLE PRECISION)
      ! AND OVERFLOW, RESPECTIVELY.
      ! !---------------

      IMPLICIT NONE
      REAL (RK), INTENT (IN) :: X
      REAL (RK) :: ERFCX_RK, AX, T, DUMY
      INTEGER :: JMIN, J, I
      INCLUDE 'CHEB_T_ERFCX_PARAMETERS_SDQ.F90'

      AX = ABS(X)

      IF (X<-9.0E0_RK) THEN
        T = X*X
        ERFCX_RK = TWO*EXP(T)
        RETURN
      ELSE

        IF (AX<=ZEPS(7)) THEN
          IF (AX<=ZEPS(1)) THEN
            ERFCX_RK = ONE - TWO_BY_SQRT_PI*X
            RETURN
          ELSE
            T = X*X
            ERFCX_RK = ZERO
            DO J = 2, 7
              IF (AX<=ZEPS(J)) THEN
                DO I = J, 2, -1
                  ERFCX_RK = T*(ERFCX_RK+C_EVEN(I)+C_ODD(I)*X)
                END DO
                ERFCX_RK = ERFCX_RK + C_EVEN(1) + X*C_ODD(1)
                RETURN
              END IF
            END DO

          END IF

          ! :- CHEBYSHEV SUBINTERVAL POLYNOMIAL APPROXIMATION
        ELSE IF (AX<=CHEB_AX) THEN
          T = TWO_P_ONE/(AX+TWO_P_ONE)
          JMIN = N_DVS*T
          JMIN = JMIN*NP_PLS_1 + 1
          ERFCX_RK = ZERO
          DO J = 1, (NP/4)
            ERFCX_RK = T*(T*(T*(T*(ERFCX_RK+CFFS(JMIN))+CFFS(JMIN+1))+CFFS(JMIN+2))+CFFS(JMIN+3))
            JMIN = JMIN + 4
          END DO
          ERFCX_RK = ERFCX_RK + CFFS(JMIN)

        ELSE

          ! :- LAPLACE CONTINUED FRACTION IN A RATIONAL FUNCTION FORM
          IF (X_VBIG<=AX) THEN
            ERFCX_RK = ONE_BY_SQRT_PI/AX

          ELSE IF (X_BIG<=AX) THEN
            ERFCX_RK = ONE_BY_SQRT_PI/(AX+HALF/X)

          ELSE

            T = AX*AX
            ERFCX_RK = ONE
            DUMY = ONE
OUTER:      DO J = 1, 4
              I = (J*(1+J))/2
              IF (XBIG_BORDER(J)<=AX) THEN
                DO JMIN = I, I + J
                  ERFCX_RK = T*ERFCX_RK + CF_NUM(JMIN)
                  DUMY = T*DUMY + CF_DNM(JMIN)
                END DO
                ERFCX_RK = (ONE_BY_SQRT_PI/AX)*ERFCX_RK/DUMY
                EXIT OUTER
              END IF
            END DO OUTER
          END IF
        END IF

        IF (X<ZERO) THEN
          T = X*X
          ERFCX_RK = TWO*EXP(T) - ERFCX_RK
        END IF
      END IF
      RETURN
    END FUNCTION

  END MODULE


